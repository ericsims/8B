control_signals:
  - OUT: # 4 bits, 16 options
    - NONE: # 0
      description: 'none'
    - PO: # 1
      description: 'Program Counter Out'
    - AO: # 2
      description: 'A Register Out'
    - BO: # 3
      description: 'B Register Out'
    - MO: # 4
      description: 'Memmory Out'
    - NO: # 5
      description: 'Stack Pointer Out'
    - SO: # 6
      description: 'Stack Out'
    - HO: # 7
      description: 'HL Register Out'
    - JO: # 8
      description: 'J Scratch Register Out'
    - KO: # 9
      description: 'K Scratch Register Out'
    - DO: # 10
      description: 'D Scratch Register Out'
    - HT: # 11
      description: 'Halt'
  - IN: # 4 bits, 16 options
    - NONE: # 0
      description: 'none'
    - PI: # 1
      description: 'Program Counter In'
    - II: # 2
      description: 'Instruction Register In'
    - XI: # 3
      description: 'ALU X Register In'
    - YI: # 4
      description: 'ALU Y Register In'
    - AI: # 5
      description: 'A Register In'
    - BI: # 6
      description: 'B Register In'
    - HI: # 7
      description: 'HL Register In'
    - MA: # 8
      description: 'Memmory Address Register In'  
    - MI: # 9
      description: 'Memmory In'
    - NI: # 10
      description: 'Stack Pointer In'
    - SI: # 11
      description: 'Stack In'
    - JI: # 12
      description: 'J Scratch Register In'
    - KI: # 13
      description: 'K Scratch Register In'
    - DI: # 14
      description: 'D Scratch Register In'
  - ALU: # 4 bits
    - NONE: # 0
      description: 'none'
    - ADD:  # 1
      description: 'Add'
    - SUB:  # 2
      description: 'Subtract'
    - AND:  # 3
      description: 'Logical AND'
    - OR:   # 4
      description: 'Logical OR'
    - XOR:  # 5
      description: 'Logical XOR'
    - SHL:  # 6
      description: 'Logical Shift Left'
    - SHR:  # 7
      description: 'Logical Shift Right'
    - ONES: # 8
      description: 'Output 0xFF'
    - INCR: # 9
      description: 'Increment'
  - CE:
    desc  iption: 'Program Counter Enable'
    active: low
  - FI:
    description: 'ALU Flag Refresh'
    active: low
  - MC:
    description: 'Memmory Address Increment'
    active: low
  - IS:
    description: 'Increment Stack Pointer'
    active: high
  - DS:
    description: 'Decrement Stack Pointer'
    active: high
  - LM:
    description: 'Bus MSB Byte Select'
    active: high
  - RU:
    description: 'Reset Microcode Counter'
    active: high

flags:
  - ZF:
    description: 'Zero Flag'
    active: high
  - CF:
    description: 'Carry Flag'
    active: high 
  - NF:
    description: 'Negative Flag'
    active: high 

instructions:
  nop:
    description: 'no operation'
    duration: 32 # clock cycles
    operands: 0 # bytes
    usage: nop
    opcode: 0x00
    asm_def: |
      nop =>
      {
        {OPCODE}
      }   
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    # nops
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - []
    - [RU]                 # Done

  load_a_imm:
    description: 'Load a register with immediate value'
    duration: 5 # clock cycles
    operands: 1 # byte (immediate data)
    usage: 'load a, #data[7:0]'
    opcode: 0x04
    asm_def: |
      load a, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [MC, CE]             # Increment MAR to point to data operand
    - [MO, AI, RU]         # load data into a register. ucode counter reset

  load_a_dir:
    description: 'load a register from direct address'
    duration: 10 # clock cycles
    operands: 2 # bytes (direct address)
    usage: 'load a, addresss[15:0]'
    opcode: 0x05
    asm_def: |
      load a, {addr: i16} =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load direct address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
      # load data
    - [MO, AI, RU]         # load data out of memory into A reg. ucode counter reset

  load_a_indir:
    description: 'load a register from indirect address'
    duration: 15 # clock cycles
    operands: 2 # bytes (indirect address)
    usage: 'load a, (address[15:0])'
    opcode: 0x06
    asm_def: |
      load a, ({addr: i16}) =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load indirect address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
      # load direct address
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC]                 # Increment MAR to point to LSB of address
    - [MO, JI]             # load address LSB into J scratch register
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
      # load data
    - [MO, AI, RU]         # load data out of memory into A reg. ucode counter reset

  load_b_imm:
    description: 'load b register with immediate value'
    duration: 5 # clock cycles
    operands: 1 # byte (immediate data)
    usage: 'load b, #data[7:0]'
    opcode: 0x08
    asm_def: |
      load b, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [MC, CE]             # Increment MAR to point to data operand
    - [MO, BI, RU]         # load data into a register. ucode counter reset

  load_b_dir:
    description: 'load b register from direct address'
    duration: 10 # clock cycles
    operands: 2 # bytes (direct address)
    usage: 'load b, addresss[15:0]'
    opcode: 0x09
    asm_def: |
      load b, {addr: i16} =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load direct address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
      # load data
    - [MO, BI, RU]         # load data out of memory into B reg. ucode counter reset

  load_b_indir:
    description: 'load a register from indirect address'
    duration: 15 # clock cycles
    operands: 2 # bytes (indirect address)
    usage: 'load b, (address[15:0])'
    opcode: 0x0A
    asm_def: |
      load b, ({addr: i16}) =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load indirect address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
      # load direct address
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC]                 # Increment MAR to point to LSB of address
    - [MO, JI]             # load address LSB into J scratch register
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
      # load data
    - [MO, BI, RU]         # load data out of memory into B reg. ucode counter reset

  loadw_hl_imm:
    description: 'load hl register with immediate word'
    duration: 7 # clock cycles
    operands: 2 # bytes (immediate data)
    usage: 'loadw hl, #data[15:0]'
    opcode: 0x0C
    asm_def: |
      loadw hl, #{imm: i16} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xffff)
        {OPCODE} @ imm`16
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [MC, CE]             # Increment MAR to point to data operand MSB. Keep up with PC
    - [MO, HI, LM]         # load data MSB into HL register MSB
    - [MC, CE]             # Increment MAR to point to data operand LSB. Keep up with PC
    - [MO, HI, RU]         # load data LSB into HL register LSB. ucode counter reset

  load_a_b:
    description: 'Load a register with value in b register'
    duration: 4 # clock cycles
    operands: 0 # bytes
    usage: 'load a, b'
    opcode: 0x13
    asm_def: |
      load a, b =>
      {
        {OPCODE}
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AI, BO, RU]         # load data into a register. ucode counter reset

  load_b_a:
    description: 'Load b register with value in a register'
    duration: 4 # clock cycles
    operands: 0 # bytes
    usage: 'load b, a'
    opcode: 0x17
    asm_def: |
      load b, a =>
      {
        {OPCODE}
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [BI, AO, RU]         # load data into b register. ucode counter reset

  add_a_b:
    description: 'add a register to b register and save to a'
    duration: 6 # clk cycles
    operands: 0 # bytes
    usage: 'add a, b'
    opcode: 0x10
    asm_def: |
      add a, b =>
      {
        {OPCODE}
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI]             # load A reg into ALU X
    - [BO, YI]             # load B reg into ALU Y
    - [ADD, AI, FI, RU]    # ADD, save to A reg, update flags. ucode counter reset

  add_a_imm:
    description: 'add a register to imm value and save to a'
    duration: 6 # clk cycles
    operands: 1 # byte (immediate data)
    usage: 'add a, #data[7:0]'
    opcode: 0x11
    asm_def: |
      add a, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI, MC, CE]     # load A reg into ALU X. increment MAR to point to data, and PC to keep up
    - [MO, YI]             # load imm value into ALU Y
    - [ADD, AI, FI, RU]    # ADD, save to A reg, update flags. ucode counter reset

  add_b_imm:
    description: 'add b register to imm value and save to b'
    duration: 6 # clk cycles
    operands: 1 # byte (immediate data)
    usage: 'add b, #data[7:0]'
    opcode: 0x12
    asm_def: |
      add b, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [BO, XI, MC, CE]     # load B reg into ALU X. increment MAR to point to data, and PC to keep up
    - [MO, YI]             # load imm value into ALU Y
    - [ADD, BI, FI, RU]    # ADD, save to B reg, update flags. ucode counter reset

  sub_a_b:
    description: 'Subtract b register from a register and save to a'
    duration: 6 # clk cycles
    operands: 0 # bytes
    usage: 'sub a, b'
    opcode: 0x18
    asm_def: |
      sub a, b =>
      {
        {OPCODE}
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI]             # load A reg into ALU X
    - [BO, YI]             # load B reg into ALU Y
    - [SUB, AI, FI, RU]    # SUBTRACT, save to A reg, update flags. ucode counter reset

  sub_a_imm:
    description: 'subtract imm value from a register and save to a'
    duration: 6 # clk cycles
    operands: 1 # byte (immediate data)
    usage: 'sub a, #data[7:0]'
    opcode: 0x19
    asm_def: |
      sub a, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI, MC, CE]     # load A reg into ALU X. increment MAR to point to data, and PC to keep up
    - [MO, YI]             # load imm value into ALU Y
    - [SUB, AI, FI, RU]    # SUBTRACT, save to A reg, update flags. ucode counter reset

  sub_b_imm:
    description: 'subtract imm value from b register and save to b'
    duration: 6 # clk cycles
    operands: 1 # byte (immediate data)
    usage: 'sub b, #data[7:0]'
    opcode: 0x1A
    asm_def: |
      sub b, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [BO, XI, MC, CE]     # load B reg into ALU X. increment MAR to point to data, and PC to keep up
    - [MO, YI]             # load imm value into ALU Y
    - [SUB, BI, FI, RU]    # SUBTRACT, save to B reg, update flags. ucode counter reset

  and_a_b:
    description: 'Logical AND a register with b register and save to a'
    duration: 6 # clk cycles
    operands: 0 # bytes
    usage: 'and a, b'
    opcode: 0x20
    asm_def: |
      and a, b =>
      {
        {OPCODE}
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI]             # load A reg into ALU X.
    - [BO, YI]             # load B reg into ALU Y.
    - [AND, AI, FI, RU]    # AND, save to A reg, update flags. ucode counter reset

  and_a_imm:
    description: 'Logical AND a register with imm value and save to a'
    duration: 6 # clk cycles
    operands: 1 # byte (immediate data)
    usage: 'and a, #data[7:0]'
    opcode: 0x21
    asm_def: |
      and a, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI, MC, CE]     # load A reg into ALU X. increment MAR to point to data, and PC to keep up
    - [MO, YI]             # load imm value into ALU Y
    - [AND, AI, FI, RU]    # AND, save to A reg, update flags. ucode counter reset

  and_b_imm:
    description: 'Logical AND b register with imm value and save to b'
    duration: 6 # clk cycles
    operands: 1 # byte (immediate data)
    usage: 'and b, #data[7:0]'
    opcode: 0x22
    asm_def: |
      and b, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [BO, XI, MC, CE]     # load B reg into ALU X. increment MAR to point to data, and PC to keep up
    - [MO, YI]             # load imm value into ALU Y
    - [AND, BI, FI, RU]    # AND, save to B reg, update flags. ucode counter reset
      
  or_a_b:
    description: 'Logical OR baregister with b register and save to a'
    duration: 6 # clk cycles
    operands: 0 # bytes
    usage: 'or a, b'
    opcode: 0x24
    asm_def: |
      or a, b =>
      {
        {OPCODE}
      }  
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI]             # load A reg into ALU X.
    - [BO, YI]             # load B reg into ALU Y.
    - [OR, AI, FI, RU]     # OR, save to A reg, update flags. ucode counter reset    

  or_a_imm:
    description: 'Logical OR a register with imm value and save to a'
    duration: 6 # clk cycles
    operands: 1 # byte (immediate data)
    usage: 'or a, #data[7:0]'
    opcode: 0x25
    asm_def: |
      or a, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI, MC, CE]     # load A reg into ALU X. increment MAR to point to data, and PC to keep up
    - [MO, YI]             # load imm value into ALU Y
    - [OR, AI, FI, RU]     # OR, save to A reg, update flags. ucode counter reset

  or_b_imm:
    description: 'Logical OR b register with imm value and save to b'
    duration: 6 # clk cycles
    operands: 1 # byte (immediate data)
    usage: 'or b, #data[7:0]'
    opcode: 0x26
    asm_def: |
      or b, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [BO, XI, MC, CE]     # load B reg into ALU X. increment MAR to point to data, and PC to keep up
    - [MO, YI]             # load imm value into ALU Y
    - [OR, BI, FI, RU]     # OR, save to B reg, update flags. ucode counter reset

      
  xor_a_b:
    description: 'Logical XOR a register with b register and save to a'
    duration: 6 # clk cycles
    operands: 0 # bytes
    usage: 'xor a, b'
    opcode: 0x28
    asm_def: |
      xor a, b =>
      {
        {OPCODE}
      }      
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI]             # load A reg into ALU X.
    - [BO, YI]             # load B reg into ALU Y.
    - [XOR, AI, FI, RU]    # XOR, save to A reg, update flags. ucode counter reset

  xor_a_imm:
    description: 'Logical XOR a register with imm value and save to a'
    duration: 6 # clk cycles
    operands: 1 # byte (immediate data)
    usage: 'xor a, #data[7:0]'
    opcode: 0x29
    asm_def: |
      xor a, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI, MC, CE]     # load A reg into ALU X. increment MAR to point to data, and PC to keep up
    - [MO, YI]             # load imm value into ALU Y
    - [XOR, AI, FI, RU]     # XOR, save to A reg, update flags. ucode counter reset

  xor_b_imm:
    description: 'Logical XOR b register with imm value and save to b'
    duration: 6 # clk cycles
    operands: 1 # byte (immediate data)
    usage: 'xor b, #data[7:0]'
    opcode: 0x2A
    asm_def: |
      xor b, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [BO, XI, MC, CE]     # load B reg into ALU X. increment MAR to point to data, and PC to keep up
    - [MO, YI]             # load imm value into ALU Y
    - [XOR, BI, FI, RU]    # XOR, save to B reg, update flags. ucode counter reset

  lshift_a:
    description: 'Logical shift left a register by one and save to a'
    duration: 5 # clk cycles
    operands: 0 # bytes
    usage: 'lshift a'
    opcode: 0x2C
    asm_def: |
      lshift a =>
      {
        {OPCODE}
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI]             # load A reg into ALU X.
    - [SHL, AI, FI, RU]    # SHL, save to A reg, update flags. ucode counter reset

  lshift_b:
    description: 'Logical shift left b register by one and save to b'
    duration: 5 # clk cycles
    operands: 0 # bytes
    usage: 'lshift b'
    opcode: 0x2D
    asm_def: |
      lshift b =>
      {
        {OPCODE}
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [BO, XI]             # load B reg into ALU X.
    - [SHL, BI, FI, RU]    # SHL, save to B reg, update flags. ucode counter reset

  rshift_a:
    description: 'Logical shift right a register by one and save to a'
    duration: 5 # clk cycles
    operands: 0 # bytes
    usage: 'rshift a'
    opcode: 0x2E
    asm_def: |
      rshift a =>
      {
        {OPCODE}
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [AO, XI]             # load A reg into ALU X.
    - [SHR, AI, FI, RU]    # SHR, save to A reg, update flags. ucode counter reset

  rshift_b:
    description: 'Logical shift right b register by one and save to b'
    duration: 5 # clk cycles
    operands: 0 # bytes
    usage: 'rshift b'
    opcode: 0x2F
    asm_def: |
      rshift b =>
      {
        {OPCODE}
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [BO, XI]             # load B reg into ALU X.
    - [SHR, BI, FI, RU]    # SHR, save to A reg, update flags. ucode counter reset

  store_a_dir:
    description: 'Store a register value to direct address'
    duration: 10 # clock cycles
    operands: 2 # byte (direct address)
    usage: 'store a, address[15:0]'
    opcode: 0x30
    asm_def: |
      store a, {addr: i16} =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load direct address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
      # save data
    - [AO, MI, RU]         # store data from A reg to memory. ucode counter reset

  store_imm_dir:
    description: 'Store imm value to direct address'
    duration: 12 # clock cycles
    operands: 3 # bytes (immediate value, direct address)
    usage: 'store #data[7:0], address[15:0]'
    opcode: 0x3D
    asm_def: |
      store #{imm: i8}, {addr: i16} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @imm`8 @ addr`16
      }
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load imm data
    - [MC, CE]             # Increment MAR to point to imm data. keep up with PC
    - [MO, DI]             # Save imm data to D scratch register
      # load direct address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
      # save data
    - [DO, MI, RU]         # store data from D scratch reg to memory. ucode counter reset

  storew_imm_dir:
    description: 'Store imm word to direct address'
    duration: 16 # clock cycles
    operands: 4 # bytes (immediate value, direct address)
    usage: 'storew #data[16:0], address[15:0]'
    opcode: 0x3E
    asm_def: |
      storew #{imm: i16}, {addr: i16} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xffff)
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @imm`16 @ addr`16
      }
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load imm data
    - [MC, CE]             # Increment MAR to point to imm MSB data. keep up with PC
    - [MO, DI, LM]         # Save imm data to D scratch register
    - [MC, CE]             # Increment MAR to point to imm LSB data. keep up with PC
    - [MO, DI]             # Save imm data to D scratch register
      # load direct address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
      # save data
    - [DO, MI, LM]         # store MSB data from D scratch reg to memory
    - [MC]                 # increment MAR to point to LSB location
    - [DO, MI, RU]         # store LSB data from D scratch reg to memory. ucode counter reset

  push_a:
    description: 'push a register value to stack'
    duration: 5 # clock cycles
    operands: 0 # bytes
    usage: 'push a'
    opcode: 0x38
    asm_def: |
      push a =>
      {
        {OPCODE}
      }
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # save data
    - [AO, SI]             # save data from D scratch register to stack
    - [DS, RU]             # decrement stack pointer. ucode counter reset

  push_b:
    description: 'push b register value to stack'
    duration: 5 # clock cycles
    operands: 0 # bytes
    usage: 'push b'
    opcode: 0x39
    asm_def: |
     push b =>
     {
       {OPCODE}
     }
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # save data
    - [BO, SI]             # save data from D scratch register to stack
    - [DS, RU]             # decrement stack pointer. ucode counter reset

  push_imm:
    description: 'push immediate value to stack'
    duration: 7 # clock cycles
    operands: 1 # byte (immedate value)
    usage: 'push #data[7:0]'
    opcode: 0x3A
    asm_def: |
      push #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load data
    - [MC, CE]             # Increment MAR to point to data. keep up with PC
    - [MO, DI]             # Load imm data to D scratch register
      # save data
    - [DO, SI]             # save data from D scratch register to stack
    - [DS, RU]             # decrement stack pointer. ucode counter reset

  push_dir:
    description: 'push byte from source to stack'
    duration: 12 # clock cycles
    operands: 2 # bytes (direct source address)
    usage: 'push address[15:0]'
    opcode: 0x3B
    asm_def: |
      push {addr: i16} =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    # load direct source address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
      # load data from source
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
    - [DI, MO]             # save data to D scratch register
      # save data
    - [DO, SI]             # save data from D scratch register to stack
    - [DS, RU]             # decrement stack pointer. ucode counter reset

  push_indir:
    description: 'push byte from indirect source to stack'
    duration: 17 # clock cycles
    operands: 2 # bytes (indirect source address)
    usage: 'push (address[15:0])'
    opcode: 0x3C
    asm_def: |
      push ({addr: i16}) =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      } 
    ucode:
      # fetch
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    # load indirect source address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
    # load direct source address
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC]                 # Increment MAR to point to LSB of address.
    - [MO, JI]             # load address LSB into J scratch register
      # load data from source
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
    - [DI, MO]             # save data to D scratch register
      # save data
    - [DO, SI]             # save data from D scratch register to stack
    - [DS, RU]             # decrement stack pointer. ucode counter reset

  move_dir_dir:
    description: 'copy byte from source to destination'
    duration: 17 # clock cycles
    operands: 4 # bytes (direct source address, direct destination address)
    usage: 'move src[15:0], dst[15:0]'
    opcode: 0x44
    asm_def: |
      move {src: i16}, {dst: i16} =>
      {
        assert(src >= 0)
        assert(src <= 0xffff)
        assert(dst >= 0)
        assert(dst <= 0xffff)
        {OPCODE} @ src`16 @ dst`16
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load direct source address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
      # load direct destination address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, KI, LM]         # load address MSB into K scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, KI]             # load address LSB into K scratch register
      # load data from source
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
    - [DI, MO]             # save data to D scratch register
      # save data to dest
    - [KO, MA, LM]         # load address out of scratch register into MAR
    - [KO, MA]             # load address out of scratch register into MAR
    - [DO, MI, RU]         # move data form D scratch register to memory. ucode counter reset
  
  move_dir_indir:
    description: 'copy byte from source to indirect destination'
    duration: 22 # clock cycles
    operands: 4 # bytes (direct source address, indirect destination address)
    usage: move src[15:0], (dst[15:0])
    opcode: 0x45
    asm_def: |
      move {src: i16}, ({dst: i16}) =>
      {
        assert(src >= 0)
        assert(src <= 0xffff)
        assert(dst >= 0)
        assert(dst <= 0xffff)
        {OPCODE} @ src`16 @ dst`16
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load direct source address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
      # load indirect destination address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, KI, LM]         # load address MSB into K scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, KI]             # load address LSB into K scratch register
      # load data from source
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
    - [DI, MO]             # save data to D scratch register
      # load direct destination address
    - [KO, MA, LM]         # load address out of scratch register into MAR
    - [KO, MA]             # load address out of scratch register into MAR
    - [MO, KI, LM]         # load address MSB into K scratch register
    - [MC]                 # Increment MAR to point to LSB of address.
    - [MO, KI]             # load address LSB into K scratch register
      # save data to dest
    - [KO, MA, LM]         # load address out of scratch register into MAR
    - [KO, MA]             # load address out of scratch register into MAR
    - [DO, MI, RU]         # move data form D scratch register to memory. ucode counter reset

  move_indir_dir:
    description: 'copy byte from indirect source to destination'
    duration: 22 # clock cycles
    operands: 4 # bytes (indirect source address, direct destination address)
    usage: move (src[15:0]), dst[15:0]
    opcode: 0x46
    asm_def: |
      move ({src: i16}), {dst: i16} =>
      {
        assert(src >= 0)
        assert(src <= 0xffff)
        assert(dst >= 0)
        assert(dst <= 0xffff)
        {OPCODE} @ src`16 @ dst`16
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load indirect source address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
      # load direct destination address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, KI, LM]         # load address MSB into K scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, KI]             # load address LSB into K scratch register
      # load direct source address
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC]                 # Increment MAR to point to LSB of address.
    - [MO, JI]             # load address LSB into J scratch register
      # load data from source
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
    - [DI, MO]             # save data to D scratch register
      # save data to dest
    - [KO, MA, LM]         # load address out of scratch register into MAR
    - [KO, MA]             # load address out of scratch register into MAR
    - [DO, MI, RU]         # move data form D scratch register to memory. ucode counter reset


  move_indir_indir:
    description: 'copy byte from indirect source to indirect destination'
    duration: 27 # clock cycles
    operands: 4 # bytes (indirect source address, indirect destination address)
    usage: move (src[15:0]), (dst[15:0])
    opcode: 0x47
    asm_def: |
      move ({src: i16}), ({dst: i16}) =>
      {
        assert(src >= 0)
        assert(src <= 0xffff)
        assert(dst >= 0)
        assert(dst <= 0xffff)
        {OPCODE} @ src`16 @ dst`16
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load indirect source address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
      # load direct destination address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, KI, LM]         # load address MSB into K scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, KI]             # load address LSB into K scratch register
      # load direct source address
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC]                 # Increment MAR to point to LSB of address.
    - [MO, JI]             # load address LSB into J scratch register
      # load data from source
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
    - [DI, MO]             # save data to D scratch register
      # load direct destination address
    - [KO, MA, LM]         # load address out of scratch register into MAR
    - [KO, MA]             # load address out of scratch register into MAR
    - [MO, KI, LM]         # load address MSB into K scratch register
    - [MC]                 # Increment MAR to point to LSB of address.
    - [MO, KI]             # load address LSB into K scratch register
      # save data to dest
    - [KO, MA, LM]         # load address out of scratch register into MAR
    - [KO, MA]             # load address out of scratch register into MAR
    - [DO, MI, RU]         # move data form D scratch register to memory. ucode counter reset


  movew_dir_dir:
    description: 'copy 2 byte word from source to destination'
    duration: 21 # clock cycles
    operands: 4 # bytes (direct source address, direct destination address)
    usage: movew src[15:0], dst[15:0]
    opcode: 0x48
    asm_def: |
      movew {src: i16}, {dst: i16} =>
      {
        assert(src >= 0)
        assert(src <= 0xffff)
        assert(dst >= 0)
        assert(dst <= 0xffff)
        {OPCODE} @ src`16 @ dst`16
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
      # load direct source address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, JI, LM]         # load address MSB into J scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, JI]             # load address LSB into J scratch register
      # load direct destination address
    - [MC, CE]             # Increment MAR to point to MSB of address. keep up with PC
    - [MO, KI, LM]         # load address MSB into K scratch register
    - [MC, CE]             # Increment MAR to point to LSB of address. keep up with PC
    - [MO, KI]             # load address LSB into K scratch register
      # load data from source
    - [JO, MA, LM]         # load address out of scratch register into MAR
    - [JO, MA]             # load address out of scratch register into MAR
    - [DI, MO, LM]         # save data MSB to D scratch register
    - [MC]                 # Increment MAR to point to LSB of data
    - [DI, MO]             # save data LSB to D scratch register
      # save data to dest
    - [KO, MA, LM]         # load address out of scratch register into MAR
    - [KO, MA]             # load address out of scratch register into MAR
    - [DO, MI, LM]         # move data MSB form D scratch register to memory
    - [MC]                 # Increment MAR to point to LSB of data
    - [DO, MI, RU]         # move data LSB form D scratch register to memory. ucode counter reset

  jmp:
    description: 'Unconditional Jump'
    duration: 7 # clock cycles
    operands: 2 # bytes (destination address)
    usage: 'jmp address[15:0]'
    opcode: 0x6C
    asm_def: |
      jmp {addr: i16} =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [MC]                 # Increment MAR to point to MSB of destiation address
    - [PI, MO, LM]         # load PC with MSB of destination address
    - [MC]                 # Increment MAR to point to LSB of destiation address
    - [PI, MO, RU]         # load PC with LSB of destination address. ucode counter reset

  jmz:
    description: 'Jump if Zero'
    duration: TBD # clock cycles
    operands: 2 # bytes (destination address)
    usage: 'jmz address[15:0]'
    opcode: 0x6D
    asm_def: |
      jmz {addr: i16} =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
      conditions: [ZF]
      false:
        - [PO, MA, LM]     # Fetch cycle, load MAR with MSB in PC
        - [PO, MA]         # Fetch cycle, load MAR with LSB in PC
        - [CE, MO, II]     # Fetch cycle, increment PC, and load instruction into IR
        - [CE]             # Increment PC to skip distation address
        - [CE, RU]         # Increment PC to skip distation address. ucode counter reset
      true:
        - [PO, MA, LM]     # Fetch cycle, load MAR with MSB in PC
        - [PO, MA]         # Fetch cycle, load MAR with LSB in PC
        - [CE, MO, II]     # Fetch cycle, increment PC, and load instruction into IR
        - [MC]             # Increment MAR to point to MSB of destiation address
        - [PI, MO, LM]     # load PC with MSB of destination address
        - [MC]             # Increment MAR to point to LSB of destiation address
        - [PI, MO, RU]     # load PC with LSB of destination address. ucode counter reset
  jnz:
    description: 'Jump if not Zero'
    duration: TBD # clock cycles
    operands: 2 # bytes (destination address)
    usage: 'jnz address[15:0]'
    opcode: 0x6E
    asm_def: |
      jnz {addr: i16} =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
      conditions: [ZF]
      false:
        - [PO, MA, LM]     # Fetch cycle, load MAR with MSB in PC
        - [PO, MA]         # Fetch cycle, load MAR with LSB in PC
        - [CE, MO, II]     # Fetch cycle, increment PC, and load instruction into IR
        - [MC]             # Increment MAR to point to MSB of destiation address
        - [PI, MO, LM]     # load PC with MSB of destination address
        - [MC]             # Increment MAR to point to LSB of destiation address
        - [PI, MO, RU]     # load PC with LSB of destination address. ucode counter reset
      true:
        - [PO, MA, LM]     # Fetch cycle, load MAR with MSB in PC
        - [PO, MA]         # Fetch cycle, load MAR with LSB in PC
        - [CE, MO, II]     # Fetch cycle, increment PC, and load instruction into IR
        - [CE]             # Increment PC to skip distation address
        - [CE, RU]         # Increment PC to skip distation address. ucode counter reset

  jmc:
    description: 'Jump if Carry'
    duration: TBD # clock cycles
    operands: 2 # bytes (destination address)
    usage: 'jmc address[15:0]'
    opcode: 0x6F
    asm_def: |
      jmc {addr: i16} =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
      conditions: [CF]
      false:
        - [PO, MA, LM]     # Fetch cycle, load MAR with MSB in PC
        - [PO, MA]         # Fetch cycle, load MAR with LSB in PC
        - [CE, MO, II]     # Fetch cycle, increment PC, and load instruction into IR
        - [CE]             # Increment PC to skip distation address
        - [CE, RU]         # Increment PC to skip distation address. ucode counter reset
      true:
        - [PO, MA, LM]     # Fetch cycle, load MAR with MSB in PC
        - [PO, MA]         # Fetch cycle, load MAR with LSB in PC
        - [CE, MO, II]     # Fetch cycle, increment PC, and load instruction into IR
        - [MC]             # Increment MAR to point to MSB of destiation address
        - [PI, MO, LM]     # load PC with MSB of destination address
        - [MC]             # Increment MAR to point to LSB of destiation address
        - [PI, MO, RU]     # load PC with LSB of destination address. ucode counter reset

  jnc:
    description: 'Jump if not Carry'
    duration: TBD # clock cycles
    operands: 2 # bytes (destination address)
    usage: 'jnc address[15:0]'
    opcode: 0x70
    asm_def: |
      jnc {addr: i16} =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
      conditions: [CF]
      false:
        - [PO, MA, LM]     # Fetch cycle, load MAR with MSB in PC
        - [PO, MA]         # Fetch cycle, load MAR with LSB in PC
        - [CE, MO, II]     # Fetch cycle, increment PC, and load instruction into IR
        - [MC]             # Increment MAR to point to MSB of destiation address
        - [PI, MO, LM]     # load PC with MSB of destination address
        - [MC]             # Increment MAR to point to LSB of destiation address
        - [PI, MO, RU]     # load PC with LSB of destination address. ucode counter reset
      true:
        - [PO, MA, LM]     # Fetch cycle, load MAR with MSB in PC
        - [PO, MA]         # Fetch cycle, load MAR with LSB in PC
        - [CE, MO, II]     # Fetch cycle, increment PC, and load instruction into IR
        - [CE]             # Increment PC to skip distation address
        - [CE, RU]         # Increment PC to skip distation address. ucode counter reset

  call:
    description: 'Call Subroutine'
    duration: 12 # clock cycles
    operands: 2 # bytes (destination address)
    usage: 'call address[15:0]'
    opcode: 0x73
    asm_def: |
      call {addr: i16} =>
      {
        assert(addr >= 0)
        assert(addr <= 0xffff)
        {OPCODE} @ addr`16
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    # setup for jump. PC need to be incremetned first, so that the corret ret address is put onto the stack
    - [MC, CE]             # Incrment MAR to point to destination address. Increment PC to skip MSB of destination address
    - [CE]                 # Increment PC to skip LSB of destination address
    # save PC to stack
    - [PO, SI, LM]         # save PC MSB to stack
    - [DS]                 # decrement stack pointer
    - [PO, SI]             # save PC LSB to stack
    - [DS]                 # decrement stack pointer
    # jump
    - [PI, MO, LM]         # load PC with MSB of destination address
    - [MC]                 # Increment MAR to point to LSB of destiation address
    - [PI, MO, RU]         # load PC with LSB of destination address. ucode counter reset

  ret:
    description: 'Return from Subroutine'
    duration: 9 # clock cycles
    operands: 0 # bytes
    usage: 'ret'
    opcode: 0x74
    asm_def: |
      ret  =>
      {
        {OPCODE}
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    # pop corret ret address is put off of the stack
    - [IS]
    - [SO, DI]             # pop LSB into D
    - [IS]
    - [SO, DI, LM]         # pop LSB into D
    # jump
    - [PI, DO, LM]         # load PC with MSB of destination address
    - [PI, DO, RU]         # load PC with LSB of destination address. ucode counter reset

  assert_a:
    description: 'Assert value of A register == imm value'
    duration: 5 # clock cycles
    operands: 1 # byte (imm data)
    usage: 'assert a, #data[7:0]'
    opcode: 0x78
    asm_def: |
      assert a, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [MC, CE]             # increment MAR to point to imm daa. increment PC to keep up               
    - [RU]                 # nop cycle for assert to take place

  assert_b:
    description: 'Assert value of b register == imm value'
    duration: 5 # clock cycles
    operands: 1 # byte (imm data)
    usage: 'assert b, #data[7:0]'
    opcode: 0x79
    asm_def: |
      assert b, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [MC, CE]             # increment MAR to point to imm daa. increment PC to keep up               
    - [RU]                 # nop cycle for assert to take place

  assert_hl:
    description: 'Assert value of hl register == imm value'
    duration: 6 # clock cycles
    operands: 2 # byte (imm data)
    usage: 'assert hl, #data[15:0]'
    opcode: 0x7A
    asm_def: |
      assert hl, #{imm: i16} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xffff)
        {OPCODE} @ imm`16
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [MC, CE]             # increment MAR to point to imm daa. increment PC to keep up
    - [MC, CE]             # increment MAR to point to imm daa. increment PC to keep up
    - [RU]                 # nop cycle for assert to take place

  assert_zf:
    description: 'Assert value of ZF == imm value'
    duration: 5 # clock cycles
    operands: 1 # byte (imm data)
    usage: 'assert zf, #data[7:0]'
    opcode: 0x7C
    asm_def: |
      assert zf, #{imm: i8} =>
      {
        assert(imm >= 0)
        assert(imm <= 0xff)
        {OPCODE} @ imm`8
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [MC, CE]             # increment MAR to point to imm daa. increment PC to keep up               
    - [RU]                 # nop cycle for assert to take place             

  halt:
    description: 'Halts execution'
    duration: 4 # clk cycles (can't execute code after this anyways)
    operands: 0 # bytes
    usage: 'halt'
    opcode: 0x7F
    asm_def: |
      halt =>
      {
        {OPCODE}
      }
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
    - [HT, RU]             # Halt

  default:
    description: 'description'
    duration: 3 # clock cycles
    operands: 0 # bytes
    # usage: TBD
    opcode: ''
    ucode:
    - [PO, MA, LM]         # Fetch cycle, load MAR with MSB in PC
    - [PO, MA]             # Fetch cycle, load MAR with LSB in PC
    - [CE, MO, II]         # Fetch cycle, increment PC, and load instruction into IR
